<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>График задолженности по выпискам</title>

  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- Чистый CSS без @apply -->
  <style>
    :root { --ring: 0 0 0 2px rgba(79,70,229,.25); }

    .card {
      border-radius: 1rem;
      background: #fff;
      box-shadow:
        0 1px 2px rgba(0,0,0,.06),
        0 8px 24px rgba(15,23,42,.06);
    }
    .btn {
      padding: .5rem 1rem;
      border-radius: .75rem;
      font-weight: 500;
      transition: transform .05s ease, background-color .15s ease, opacity .15s ease;
      cursor: pointer; user-select: none;
    }
    .btn:active { transform: translateY(1px); }
    .btn-primary { background: #4f46e5; color: #fff; }
    .btn-primary:hover { background: #4338ca; }
    .btn-primary:active { background: #3730a3; }
    .btn-secondary { background: #f1f5f9; color: #334155; }
    .btn-secondary:hover { background: #e2e8f0; }
    .btn-secondary:active { background: #cbd5e1; }
    .btn-danger { background:#e11d48; color:#fff; }
    .btn-danger:hover { background:#be123c; }
    .btn-danger:active { background:#9f1239; }

    .chip { font-size: .75rem; padding: .125rem .5rem; border-radius: 9999px; background: #f1f5f9; color:#334155; }
    .mono { font-variant-numeric: tabular-nums; }

    textarea:focus, input[type="text"]:focus {
      outline: none; box-shadow: var(--ring); border-color: #6366f1;
    }

    /* Ширина/высота графика */
    .chart-wrap { height: 520px; }

    /* Белая таблица */
    .table-white { background: #ffffff !important; color: #0f172a; }
    .table-white > div, .table-white table { background: #ffffff !important; }
    .table-white table { width: 100%; border-collapse: separate; border-spacing: 0; }
    .table-white thead th {
      background: #f8fafc !important;
      color: #334155 !important;
      font-weight: 600;
      border-bottom: 1px solid #e2e8f0;
    }
    .table-white tbody td {
      background: #ffffff !important;
      color: #0f172a !important;
      border-bottom: 1px solid #f1f5f9;
    }
    .table-white tbody tr:hover td { background: #f8fafc !important; }
  </style>
</head>
<body class="bg-slate-50 text-slate-900 min-h-screen">
  <div class="max-w-[1400px] mx-auto p-4 md:p-8 space-y-6">
    <header class="flex flex-col md:flex-row md:items-end md:justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">График задолженности по кредитному продукту</h1>
        <p class="text-sm text-slate-600 mt-1">
          Вставляйте месячные выписки — инструмент добавит период в общую ленту и построит диаграмму динамики погашения долга.
        </p>
      </div>
      <div class="flex gap-2">
        <button id="downloadChartBtn" class="btn btn-primary">Скачать диаграмму (PNG)</button>
        <button id="exportJsonBtn" class="btn btn-secondary" title="Выгрузить данные в JSON">Экспорт JSON</button>
        <button id="importJsonBtn" class="btn btn-secondary" title="Загрузить сохранённый JSON">Импорт JSON</button>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
      </div>
    </header>

    <!-- Ввод выписки -->
    <section class="card p-4 md:p-6 space-y-4">
      <div class="flex items-center justify-between">
        <h2 class="text-xl font-semibold">Вставьте текст выписки за 1 месяц</h2>
        <span class="chip">Поддерживается структура, как в примере</span>
      </div>

      <textarea id="statementInput" rows="10"
        class="w-full rounded-xl border border-slate-200 p-3 mono"
        placeholder="Выписка за период с 17 июня по 16 июля
Долг по выписке
−79 677,76 ₽
Минимальный платеж
−6 100 ₽
Дата мин. платежа
10.08.2025
* Баланс на начало периода
  −92 892,26

* Баланс на конец периода
  −79 677,76

* Начисленные проценты
  −3 743,59

* Расходы
  −941,91

* Поступления
  17 900
..."></textarea>

      <div class="flex flex-wrap gap-2">
        <button id="parseBtn" class="btn btn-primary">Распарсить</button>
        <button id="clearInputBtn" class="btn btn-secondary">Очистить</button>
        <button id="quickAddBtn" class="btn btn-primary">Добавить в диаграмму</button>
      </div>

      <div id="parsePreview"
           class="hidden mt-2 p-3 rounded-xl bg-slate-50 border border-slate-200 text-sm grid grid-cols-1 md:grid-cols-2 gap-3"></div>

      <div class="flex justify-end">
        <button id="addRecordBtn" class="btn btn-primary disabled:opacity-50" disabled>Добавить период (через предпросмотр)</button>
      </div>
    </section>

    <!-- Диаграмма -->
    <section class="card p-4 md:p-6">
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center gap-3">
          <h2 class="text-xl font-semibold">Диаграмма динамики задолженности</h2>
          <div class="ml-4 inline-flex rounded-xl overflow-hidden border border-slate-200">
            <button id="tabLineBtn" class="px-3 py-1.5 text-sm bg-indigo-600 text-white">Линейная</button>
            <button id="tabBarBtn"  class="px-3 py-1.5 text-sm bg-white text-slate-700 hover:bg-slate-50">Блоковая</button>
          </div>
        </div>
        <div class="flex gap-3 items-center text-sm">
          <label class="flex items-center gap-2"><input type="checkbox" id="showMinPay" class="rounded" checked>Мин. платеж</label>
          <label class="flex items-center gap-2"><input type="checkbox" id="showInterest" class="rounded">Проценты</label>
          <label class="flex items-center gap-2"><input type="checkbox" id="showIncome" class="rounded">Поступления</label>
          <label class="flex items-center gap-2"><input type="checkbox" id="showSpend" class="rounded">Расходы</label>
        </div>
      </div>
      <div id="chartLineWrap" class="relative chart-wrap">
        <canvas id="debtChart" height="420"></canvas>
      </div>
      <div id="chartBarWrap" class="relative chart-wrap hidden">
        <canvas id="barChart" height="420"></canvas>
      </div>
    </section>

    <!-- Таблица периодов -->
    <section class="card p-4 md:p-6 table-white">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-xl font-semibold">Периоды</h2>
        <div class="text-sm text-slate-500">Хранится локально (LocalStorage)</div>
      </div>
      <div class="overflow-x-auto">
        <table class="min-w-full text-sm">
          <thead>
            <tr class="text-left">
              <th class="py-2 pr-4">Период</th>
              <th class="py-2 pr-4">Долг по выписке</th>
              <th class="py-2 pr-4">Баланс конец периода</th>
              <th class="py-2 pr-4">Мин. платёж</th>
              <th class="py-2 pr-4">Проценты</th>
              <th class="py-2 pr-4">Поступления</th>
              <th class="py-2 pr-4">Расходы</th>
              <th class="py-2 pr-4">Просрочка</th>
              <th class="py-2 pr-4">Действия</th>
            </tr>
          </thead>
          <tbody id="periodsTableBody"></tbody>
        </table>
      </div>
    </section>

    <footer class="py-6 text-center text-xs text-slate-500">
      © Кредитный трекер · Локально, без сервера
    </footer>
  </div>

  <script>
    // ====== Цвета серий ======
    const COLORS = {
      debt:    '#3b82f6', // синий
      income:  '#22c55e', // зелёный
      spend:   '#ef4444', // красный
      interest:'#ea580c', // тёмно-оранжевый
      minPay:  '#a855f7', // фиолетовый
      grid:    'rgba(0,0,0,0.06)',
      ticks:   '#475569',
      legend:  '#334155'
    };

    // ====== Утилиты парсинга/форматирования ======
    const nbsp = /\u00A0/g, spaces = /\s+/g;

    function parseRub(raw) {
      if (!raw) return null;
      const s = String(raw)
        .replace(nbsp, ' ')
        .replace(/[\u2212\u2012\u2013\u2014]/g, '-') // unicode минусы → обычный
        .replace(/[^\d,\-\s]/g, '')
        .replace(spaces, '')
        .replace(',', '.');
      const val = parseFloat(s);
      return isNaN(val) ? null : val;
    }

    const rubFmt = new Intl.NumberFormat('ru-RU', { style:'currency', currency:'RUB', maximumFractionDigits:2 });
    const safe = (s) => (s || '').trim();
    const extract = (re, text) => { const m = text.match(re); return m ? safe(m[1]) : ''; };

    function parsePeriodLabel(text) {
      const m = text.match(/Выписка\s+за\s+период\s+с\s+(.+?)\s+по\s+(.+?)(?:\n|$)/i);
      return m ? `${m[1]} — ${m[2]}` : '';
    }

    function parseStatement(text) {
      const t = text.replace(nbsp, ' ').trim();
      const period = parsePeriodLabel(t);
      const debtStr     = extract(/Долг\s+по\s+выписке\s*\n\s*([^\n]+)/i, t);
      const minPayStr   = extract(/Минимальный\s+платеж\s*\n\s*([^\n]+)/i, t);
      const minPayDate  = extract(/Дата\s+мин\.?\s*платежа\s*\n\s*([^\n]+)/i, t);
      const balStartStr = extract(/\*\s*Баланс\s+на\s+начало\s+периода\s*\n\s*([^\n]+)/i, t);
      const balEndStr   = extract(/\*\s*Баланс\s+на\s+конец\s+периода\s*\n\s*([^\n]+)/i, t);
      const interestStr = extract(/\*\s*Начисленные\s+проценты\s*\n\s*([^\n]+)/i, t);
      const incomeStr   = extract(/\*\s*Поступления\s*\n\s*([^\n]+)/i, t);
      const spendStr    = extract(/\*\s*Расходы\s*\n\s*([^\n]+)/i, t);

      return {
        id: crypto.randomUUID(),
        period,
        debt:     parseRub(debtStr),
        minPay:   parseRub(minPayStr),
        minPayDate: safe(minPayDate),
        balStart: parseRub(balStartStr),
        balEnd:   parseRub(balEndStr),
        interest: parseRub(interestStr),
        income:   parseRub(incomeStr),
        spend:    parseRub(spendStr),
        raw: t,
      };
    }

    // ====== LocalStorage ======
    const STORAGE_KEY = 'credit-tracker-periods-v1';
    const loadData = () => { try { const s = localStorage.getItem(STORAGE_KEY); return s ? JSON.parse(s) : []; } catch { return []; } };
    const saveData = (list) => localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    let periods = loadData();

    // ====== Элементы UI ======
    const statementInput = document.getElementById('statementInput');
    const parseBtn       = document.getElementById('parseBtn');
    const clearInputBtn  = document.getElementById('clearInputBtn');
    const quickAddBtn    = document.getElementById('quickAddBtn');
    const parsePreview   = document.getElementById('parsePreview');
    const addRecordBtn   = document.getElementById('addRecordBtn');
    const tbody          = document.getElementById('periodsTableBody');

    let lastParsed = null;

    function renderPreview(d) {
      parsePreview.innerHTML = '';
      const fields = [
        ['Период', d.period],
        ['Долг по выписке', d.debt!=null ? rubFmt.format(d.debt) : '—'],
        ['Баланс начало периода', d.balStart!=null ? rubFmt.format(d.balStart) : '—'],
        ['Баланс конец периода', d.balEnd!=null ? rubFmt.format(d.balEnd) : '—'],
        ['Мин. платёж', d.minPay!=null ? rubFmt.format(d.minPay) : '—'],
        ['Дата мин. платежа', d.minPayDate || '—'],
        ['Начисленные проценты', d.interest!=null ? rubFmt.format(d.interest) : '—'],
        ['Поступления', d.income!=null ? rubFmt.format(d.income) : '—'],
        ['Расходы', d.spend!=null ? rubFmt.format(d.spend) : '—'],
      ];
      for (const [label, val] of fields) {
        const row = document.createElement('div');
        row.className = 'flex items-center justify-between gap-3';
        row.innerHTML = `<div class="text-slate-500">${label}</div><div class="font-medium mono">${val}</div>`;
        parsePreview.appendChild(row);
      }
      parsePreview.classList.remove('hidden');
    }

    parseBtn.addEventListener('click', () => {
      const text = statementInput.value.trim();
      if (!text) { parsePreview.classList.add('hidden'); addRecordBtn.disabled = true; return; }
      const parsed = parseStatement(text);
      lastParsed = parsed;
      renderPreview(parsed);
      const ok = parsed.period && (parsed.balEnd!=null || parsed.debt!=null);
      addRecordBtn.disabled = !ok;
    });
    clearInputBtn.addEventListener('click', () => {
      statementInput.value = '';
      parsePreview.classList.add('hidden');
      addRecordBtn.disabled = true;
    });
    addRecordBtn.addEventListener('click', () => {
      if (!lastParsed) return;
      periods.push(lastParsed); saveData(periods);
      lastParsed = null; statementInput.value = '';
      parsePreview.classList.add('hidden'); addRecordBtn.disabled = true;
      renderTable(); rebuildChart();
    });
    // Быстрое добавление
    quickAddBtn.addEventListener('click', () => {
      const text = statementInput.value.trim();
      if (!text) { alert('Вставьте текст выписки.'); return; }
      const parsed = parseStatement(text);
      const ok = parsed.period && (parsed.balEnd!=null || parsed.debt!=null);
      if (!ok) { alert('Не удалось распознать ключевые поля (Период и Баланс/Долг). Проверьте структуру текста.'); return; }
      periods.push(parsed); saveData(periods);
      statementInput.value = ''; parsePreview.classList.add('hidden'); addRecordBtn.disabled = true;
      renderTable(); rebuildChart();
    });

    // ====== Таблица ======
    function renderTable() {
      tbody.innerHTML = '';
      periods.forEach((p, idx) => {
        const tr = document.createElement('tr');
        tr.className = 'border-b border-slate-100';
        tr.innerHTML = `
          <td class="py-2 pr-4">${p.period || '—'}</td>
          <td class="py-2 pr-4 mono">${p.debt!=null ? rubFmt.format(p.debt) : '—'}</td>
          <td class="py-2 pr-4 mono">${p.balEnd!=null ? rubFmt.format(p.balEnd) : '—'}</td>
          <td class="py-2 pr-4 mono">${p.minPay!=null ? rubFmt.format(p.minPay) : '—'}</td>
          <td class="py-2 pr-4 mono">${p.interest!=null ? rubFmt.format(p.interest) : '—'}</td>
          <td class="py-2 pr-4 mono">${p.income!=null ? rubFmt.format(p.income) : '—'}</td>
          <td class="py-2 pr-4 mono">${p.spend!=null ? rubFmt.format(p.spend) : '—'}</td>
          <td class="py-2 pr-4">
            <label class="inline-flex items-center gap-2 text-sm"><input type="checkbox" data-action="overdue-toggle" data-idx="${idx}" ${p.overdue ? 'checked' : ''}/> <span>Да</span></label>
          </td>
          <td class="py-2 pr-4">
            <div class="flex gap-2">
              <button class="btn btn-secondary" data-action="edit" data-idx="${idx}">Править</button>
              <button class="btn btn-danger" data-action="del" data-idx="${idx}">Удалить</button>
            </div>
          </td>
        `;
        tbody.appendChild(tr);
      });
    }

    tbody.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action]');
      if (!btn) return;
      const idx = +btn.dataset.idx;
      const action = btn.dataset.action;
      if (action === 'del') {
        if (confirm('Удалить этот период?')) {
          periods.splice(idx, 1); saveData(periods);
          renderTable(); rebuildChart();
        }
      } else if (action === 'edit') {
        const p = periods[idx];
        const text = prompt('Отредактируйте период (только подпись):', p.period || '');
        if (text !== null) {
          p.period = text.trim(); saveData(periods);
          renderTable(); rebuildChart();
        }
      }
    });

    tbody.addEventListener('change', (e) => {
      const cb = e.target.closest('input[type="checkbox"][data-action="overdue-toggle"]');
      if (!cb) return;
      const idx = +cb.dataset.idx;
      periods[idx].overdue = cb.checked;
      saveData(periods);
      rebuildChart();
    });

    // ====== Диаграмма ======
    const canvasEl = document.getElementById('debtChart');
    let chart = null;      // линейная
    let barChart = null;   // блоковая (столбиковая)

    // Белый фон для PNG
    const whiteBgPlugin = {
      id: 'whiteBg',
      beforeDraw(chart) {
        const {ctx, width, height} = chart;
        ctx.save();
        ctx.globalCompositeOperation = 'destination-over';
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }
    };

    // Тень для линий
    const shadowLinePlugin = {
      id: 'shadowLine',
      beforeDatasetsDraw(chart) {
        const { ctx } = chart;
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.25)';
        ctx.shadowBlur = 14;
        ctx.shadowOffsetY = 6;
      },
      afterDatasetsDraw(chart) { chart.ctx.restore(); }
    };

    // Светло-красные вертикальные бэнды для просрочек
    const overdueBandsPlugin = {
      id: 'overdueBands',
      beforeDatasetsDraw(chart) {
        const { ctx, chartArea, scales } = chart;
        const xScale = scales.x; const yScale = scales.y;
        if (!xScale || !yScale) return;
        ctx.save();
        ctx.fillStyle = 'rgba(239,68,68,0.10)';
        const meta = chart.getDatasetMeta(0);
        const points = meta?.data || [];
        periods.forEach((p, i) => {
          if (!p.overdue) return;
          let centerX = points[i]?.x ?? xScale.getPixelForTick(i);
          const prevX = points[i-1]?.x ?? xScale.getPixelForTick(Math.max(0, i-1));
          const nextX = points[i+1]?.x ?? xScale.getPixelForTick(Math.min(xScale.ticks.length-1, i+1));
          const halfWidth = Math.max(12, Math.min((nextX - centerX)/2, (centerX - prevX)/2) || 24);
          let leftX = Math.max(chartArea.left, centerX - halfWidth);
          let rightX = Math.min(chartArea.right, centerX + halfWidth);
          ctx.fillRect(leftX, chartArea.top, rightX - leftX, chartArea.bottom - chartArea.top);
        });
        ctx.restore();
      }
    };

    // Толстая горизонтальная линия на уровне 0
    const zeroLinePlugin = {
      id: 'zeroLine',
      beforeDatasetsDraw(chart) {
        const { ctx, chartArea, scales } = chart;
        const yScale = scales.y; const xScale = scales.x;
        if (!yScale || !xScale) return;
        const y0 = yScale.getPixelForValue(0);
        // Рисуем только если 0 попадает в видимую область
        if (isNaN(y0) || y0 < chartArea.top || y0 > chartArea.bottom) return;
        ctx.save();
        // без теней и эффектов
        ctx.shadowColor = 'transparent';
        ctx.beginPath();
        ctx.moveTo(chartArea.left, y0);
        ctx.lineTo(chartArea.right, y0);
        ctx.lineWidth = 3;                 // более жирная
        ctx.strokeStyle = '#64748b';       // slate-500
        ctx.setLineDash([]);               // сплошная
        ctx.stroke();
        ctx.restore();
      }
    };

    // Таблички со значениями (всегда на диаграмме + попадают в экспорт) — улучшенное разведение по вертикали
    const valueLabelsPlugin = {
      id: 'valueLabels',
      afterDatasetsDraw(chart) {
        const { ctx, chartArea, scales } = chart;
        const xScale = scales.x; const yScale = scales.y;
        if (!xScale || !yScale) return;

        ctx.save();
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial';
        ctx.textBaseline = 'middle';
        const padX = 8, radius = 5, boxH = 24, MARGIN = 4; // MARGIN — минимальный зазор между боксами

        // Храним все размещённые прямоугольники (для всех датасетов)
        const placed = [];
        const intersects = (a, b) => !(a.x + a.w + MARGIN <= b.x || b.x + b.w + MARGIN <= a.x || a.y + a.h + MARGIN <= b.y || b.y + b.h + MARGIN <= a.y);
        function drawRoundedRect(x, y, w, h, r) {
          ctx.beginPath();
          ctx.moveTo(x+r, y);
          ctx.lineTo(x+w-r, y);
          ctx.quadraticCurveTo(x+w, y, x+w, y+r);
          ctx.lineTo(x+w, y+h-r);
          ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
          ctx.lineTo(x+r, y+h);
          ctx.quadraticCurveTo(x, y+h, x, y+h-r);
          ctx.lineTo(x, y+r);
          ctx.quadraticCurveTo(x, y, x+r, y);
          ctx.closePath();
        }

        // Обходим датасеты в порядке их отрисовки (синий первый) — это даёт стабильный слой
        chart.data.datasets.forEach((ds, di) => {
          const meta = chart.getDatasetMeta(di);
          if (!meta || meta.hidden) return;
          const points = meta.data || [];
          const stroke = ds.borderColor || '#0f172a';

          for (let i = 0; i < points.length; i++) {
            const pt = points[i];
            const val = ds.data[i];
            if (!pt || val == null || isNaN(val)) continue;

            const labelText = rubFmt.format(val);
            const textW = ctx.measureText(labelText).width;
            const boxW = Math.ceil(textW + padX*2);

            const cx = pt.x, cy = pt.y;
            // Базовая позиция: для чётных датасетов пытаемся вверх, для нечётных — вниз (лучше разводит ряды)
            let prefAbove = (di % 2 === 0);
            let startY = prefAbove ? Math.round(cy - 12 - boxH) : Math.round(cy + 12);
            // Если не помещается сверху — стартуем снизу и наоборот
            if (prefAbove && startY < chartArea.top + 2) startY = Math.round(cy + 12);
            if (!prefAbove && startY + boxH > chartArea.bottom - 2) startY = Math.round(cy - 12 - boxH);

            // Начальный кандидат
            let candidate = { x: Math.round(cx - boxW/2), y: startY, w: boxW, h: boxH };
            // Доводим по X в пределы чарта
            if (candidate.x < chartArea.left + 2) candidate.x = chartArea.left + 2;
            if (candidate.x + candidate.w > chartArea.right - 2) candidate.x = chartArea.right - 2 - candidate.w;

            // Поиск свободного вертикального положения
            let tries = 0;
            while (placed.some(r => intersects(r, candidate)) && tries < 32) {
              // Чередуем направление и постепенно уводим выше/ниже
              const dir = (tries % 2 === 0 ? -1 : 1) * (prefAbove ? 1 : -1);
              candidate.y += dir * (boxH + 6);
              // Клаймп в пределах области
              if (candidate.y < chartArea.top + 2) candidate.y = chartArea.top + 2;
              if (candidate.y + candidate.h > chartArea.bottom - 2) candidate.y = chartArea.bottom - 2 - candidate.h;
              tries++;
            }

            // Соединительная «ножка» к точке
            ctx.strokeStyle = stroke;
            ctx.fillStyle = '#ffffff';
            ctx.lineWidth = 1;
            const legX = Math.max(candidate.x+radius, Math.min(cx, candidate.x+candidate.w-radius));
            const legY = candidate.y < cy ? candidate.y + candidate.h : candidate.y;
            ctx.beginPath(); ctx.moveTo(legX, legY); ctx.lineTo(cx, cy); ctx.stroke();

            // Бокс
            drawRoundedRect(candidate.x, candidate.y, candidate.w, candidate.h, radius);
            ctx.fill(); ctx.stroke();

            // Текст
            ctx.fillStyle = '#0f172a';
            ctx.fillText(labelText, candidate.x + padX, candidate.y + candidate.h/2);

            placed.push(candidate);
          }
        });

        ctx.restore();
      }
    };

    // Смещение ряда на один период вперёд (для мин. платежей)
    function shiftForward(arr) {
      const out = new Array(arr.length).fill(null);
      for (let i = 0; i < arr.length - 1; i++) {
        const v = arr[i];
        out[i + 1] = (v == null || isNaN(v)) ? null : v;
      }
      return out;
    }

    function datasetsFrom(periods) {
      const labels = periods.map(p => p.period || '—');
      const debtSeries     = periods.map(p => (p.balEnd!=null ? p.balEnd : (p.debt!=null ? p.debt : null)));
      const minPaySeries   = periods.map(p => p.minPay ?? null);
      const interestSeries = periods.map(p => p.interest ?? null);
      const incomeSeries   = periods.map(p => p.income ?? null);
      const spendSeries    = periods.map(p => p.spend  ?? null);
      return { labels, debtSeries, minPaySeries, interestSeries, incomeSeries, spendSeries };
    }

    function rebuildChart() {
      const { labels, debtSeries, minPaySeries, interestSeries, incomeSeries, spendSeries } = datasetsFrom(periods);
      const minPayShifted = shiftForward(minPaySeries);
      const showMin = document.getElementById('showMinPay').checked;
      const showInt = document.getElementById('showInterest').checked;
      const showInc = document.getElementById('showIncome').checked;
      const showSpd = document.getElementById('showSpend').checked;

      const ds = [
        {
          label: 'Задолженность (конец периода)',
          data: debtSeries,
          borderColor: COLORS.debt,
          pointBackgroundColor: COLORS.debt,
          pointBorderColor: COLORS.debt,
          tension: 0.35,
          borderWidth: 3,
          pointRadius: 4,
          pointHoverRadius: 5,
          fill: false,
        }
      ];
      if (showMin) ds.push({
        label: 'Минимальный платёж',
        data: minPayShifted,
        borderColor: COLORS.minPay,
        pointBackgroundColor: COLORS.minPay,
        pointBorderColor: COLORS.minPay,
        tension: 0.3, borderWidth: 4, pointRadius: 3, fill: false,
        borderDash: [6,6]
      });
      if (showInt) ds.push({
        label: 'Начисленные проценты',
        data: interestSeries,
        borderColor: COLORS.interest,
        pointBackgroundColor: COLORS.interest,
        pointBorderColor: COLORS.interest,
        tension: 0.3, borderWidth: 4, pointRadius: 3, fill: false,
        borderDash: [2,4]
      });
      if (showInc) ds.push({
        label: 'Поступления',
        data: incomeSeries,
        borderColor: COLORS.income,
        pointBackgroundColor: COLORS.income,
        pointBorderColor: COLORS.income,
        tension: 0.3, borderWidth: 4, pointRadius: 3, fill: false,
        borderDash: [10,6,2,6]
      });
      if (showSpd) ds.push({
        label: 'Расходы',
        data: spendSeries,
        borderColor: COLORS.spend,
        pointBackgroundColor: COLORS.spend,
        pointBorderColor: COLORS.spend,
        tension: 0.3, borderWidth: 4, pointRadius: 3, fill: false,
        borderDash: [1,5]
      });

      const config = {
        type: 'line',
        data: { labels, datasets: ds },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', intersect: false },
          cubicInterpolationMode: 'monotone',
          plugins: {
            legend: { display: true, labels: { usePointStyle: true, color: COLORS.legend, boxWidth: 10, padding: 16 } },
            tooltip: {
              enabled: false // выключаем всплывающие, т.к. есть постоянные таблички
            }
          },
          scales: {
            x: { grid: { color: COLORS.grid, drawBorder: false }, ticks: { color: COLORS.ticks } },
            y: { grid: { color: COLORS.grid, drawBorder: false }, ticks: { color: COLORS.ticks, callback: (v) => rubFmt.format(v) } }
          }
        },
        plugins: [whiteBgPlugin, overdueBandsPlugin, zeroLinePlugin, shadowLinePlugin, valueLabelsPlugin]
      };

      if (chart) chart.destroy();
      chart = new Chart(canvasEl, config);
    }

    // ====== Блоковая (столбиковая) диаграмма ======
    function rebuildBarChart() {
      const { labels, debtSeries, minPaySeries, interestSeries, incomeSeries, spendSeries } = datasetsFrom(periods);
      const minPayShifted = shiftForward(minPaySeries);
      const showMin = document.getElementById('showMinPay').checked;
      const showInt = document.getElementById('showInterest').checked;
      const showInc = document.getElementById('showIncome').checked;
      const showSpd = document.getElementById('showSpend').checked;

      const ds = [
        {
          label: 'Задолженность (конец периода)',
          data: debtSeries,
          type: 'bar',
          backgroundColor: 'rgba(59,130,246,0.25)',
          borderColor: COLORS.debt,
          borderWidth: 1,
          borderRadius: 6,
        }
      ];
      if (showMin) ds.push({
        label: 'Минимальный платёж',
        data: minPayShifted,
        type: 'bar',
        backgroundColor: 'rgba(168,85,247,0.25)',
        borderColor: COLORS.minPay,
        borderWidth: 1,
        borderRadius: 6,
      });
      if (showInt) ds.push({
        label: 'Начисленные проценты',
        data: interestSeries,
        type: 'bar',
        backgroundColor: 'rgba(234,88,12,0.25)',
        borderColor: COLORS.interest,
        borderWidth: 1,
        borderRadius: 6,
      });
      if (showInc) ds.push({
        label: 'Поступления',
        data: incomeSeries,
        type: 'bar',
        backgroundColor: 'rgba(34,197,94,0.25)',
        borderColor: COLORS.income,
        borderWidth: 1,
        borderRadius: 6,
      });
      if (showSpd) ds.push({
        label: 'Расходы',
        data: spendSeries,
        type: 'bar',
        backgroundColor: 'rgba(239,68,68,0.25)',
        borderColor: COLORS.spend,
        borderWidth: 1,
        borderRadius: 6,
      });

      const barCtx = document.getElementById('barChart');
      const config = {
        type: 'bar',
        data: { labels, datasets: ds },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { display: true, labels: { usePointStyle: false, color: COLORS.legend, padding: 16 } },
            tooltip: { enabled: false }
          },
          scales: {
            x: { grid: { color: COLORS.grid, drawBorder: false }, ticks: { color: COLORS.ticks }, stacked: false },
            y: { grid: { color: COLORS.grid, drawBorder: false }, ticks: { color: COLORS.ticks, callback: (v)=>rubFmt.format(v) } }
          }
        },
        plugins: [whiteBgPlugin, overdueBandsPlugin, zeroLinePlugin, valueLabelsPlugin]
      };

      if (barChart) barChart.destroy();
      barChart = new Chart(barCtx, config);
    }

    document.getElementById('showMinPay').addEventListener('change', ()=>{ rebuildChart(); rebuildBarChart(); });
    document.getElementById('showInterest').addEventListener('change', ()=>{ rebuildChart(); rebuildBarChart(); });
    document.getElementById('showIncome').addEventListener('change', ()=>{ rebuildChart(); rebuildBarChart(); });
    document.getElementById('showSpend').addEventListener('change', ()=>{ rebuildChart(); rebuildBarChart(); });

    // ====== Экспорт/Импорт JSON ======
    const exportBtn = document.getElementById('exportJsonBtn');
    const importBtn = document.getElementById('importJsonBtn');
    const importFile = document.getElementById('importFile');

    exportBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(periods, null, 2)], { type: 'application/json;charset=utf-8' });
      saveAs(blob, 'credit-periods.json');
    });
    importBtn.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          if (Array.isArray(data)) { periods = data; saveData(periods); renderTable(); rebuildChart(); }
          else alert('Неверный формат JSON');
        } catch { alert('Не удалось прочитать JSON'); }
      };
      reader.readAsText(file, 'utf-8');
      importFile.value = '';
    });

    // ====== Табы: линейная/блоковая ======
    const tabLineBtn = document.getElementById('tabLineBtn');
    const tabBarBtn  = document.getElementById('tabBarBtn');
    const chartLineWrap = document.getElementById('chartLineWrap');
    const chartBarWrap  = document.getElementById('chartBarWrap');
    let currentTab = 'line';

    function activateTab(name){
      currentTab = name;
      if (name==='line') {
        chartLineWrap.classList.remove('hidden');
        chartBarWrap.classList.add('hidden');
        tabLineBtn.className = 'px-3 py-1.5 text-sm bg-indigo-600 text-white';
        tabBarBtn.className  = 'px-3 py-1.5 text-sm bg-white text-slate-700 hover:bg-slate-50';
        if (chart) chart.resize();
      } else {
        chartBarWrap.classList.remove('hidden');
        chartLineWrap.classList.add('hidden');
        tabBarBtn.className  = 'px-3 py-1.5 text-sm bg-indigo-600 text-white';
        tabLineBtn.className = 'px-3 py-1.5 text-sm bg-white text-slate-700 hover:bg-slate-50';
        // лениво пересобираем столбиковую при первом показе
        if (!barChart) rebuildBarChart(); else barChart.resize();
      }
    }

    tabLineBtn.addEventListener('click', ()=>activateTab('line'));
    tabBarBtn.addEventListener('click', ()=>activateTab('bar'));

    // ====== Скачивание PNG (белый фон + 3x DPI) ======
    const downloadBtn = document.getElementById('downloadChartBtn');
    downloadBtn.addEventListener('click', () => {
      const activeChart = (currentTab==='bar') ? barChart : chart;
      if (!activeChart) return;
      const prev = activeChart.options.devicePixelRatio ?? Chart.defaults.devicePixelRatio;
      activeChart.options.devicePixelRatio = 3;
      activeChart.update();
      const url = activeChart.toBase64Image('image/png', 1.0);
      activeChart.options.devicePixelRatio = prev;
      activeChart.update();

      const a = document.createElement('a');
      a.href = url;
      const now = new Date();
      a.download = `debt-${currentTab}-chart-${now.toISOString().slice(0,10)}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });

    // ====== Инициализация ======
    renderTable();
    rebuildChart();
    // Столбиковую можно собрать сразу, но держим скрытой
    // rebuildBarChart();
  </script>
</body>
</html>